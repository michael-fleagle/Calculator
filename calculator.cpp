// Michael Fleagle
// CS480

#include "calculator.h"
#include "./ui_calculator.h"

// add Qt math to handle match functions and vectors to use in place of arrays
#include <QtMath>
#include <vector>
#include <cmath>

// namesapce std for ease of use
using namespace std;

// create value to hold calculation value
double calcVal = 0.0;

// create two vectors to hold the output and operator stack
vector<QString> output;
vector<QString> operators;
vector<QString> input;

Calculator::Calculator(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::Calculator)
{
    ui->setupUi(this);

    // All code above this is generated by the Qt creator software //

    // show the text in the UI Display
    ui->Display->setText(QString::number(calcVal));

    // set up buttons for numbers
    QPushButton *numButtons[10];
    for(int i = 0; i < 10; i++)
    {
        QString buttonName = "Button_" + QString::number(i);
        numButtons[i] = Calculator::findChild<QPushButton *>(buttonName);
        connect(numButtons[i], SIGNAL(released()), this, SLOT(NumPressed()));
    }

    // set up . button
    connect(ui->Button_Period, SIGNAL(released()), this, SLOT(NumPressed()));

    // set up + button
    connect(ui->Button_Plus, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up - button
    connect(ui->Button_Min, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up * button
    connect(ui->Button_Mult, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up / button
    connect(ui->Button_Div, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up ^ button
    connect(ui->Button_Pow, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up sin button
    connect(ui->Button_Sin, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up cos button
    connect(ui->Button_Cos, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up tan button
    connect(ui->Button_Tan, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up cot button
    connect(ui->Button_Cot, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up ln button
    connect(ui->Button_NatLog, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up log button
    connect(ui->Button_Log, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up ( button
    connect(ui->Button_Paren_Open, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up ) button
    connect(ui->Button_Paren_Close, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up { button
    connect(ui->Button_Bracket_Open, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up } button
    connect(ui->Button_Bracket_Close, SIGNAL(released()), this, SLOT(OperatorButtonPressed()));

    // set up clear button
    connect(ui->Button_Clear, SIGNAL(released()), this, SLOT(ClearButtonPressed()));

    // set up backspace button
    connect(ui->Button_Back, SIGNAL(released()), this, SLOT(BackButtonPressed()));

    // set up unary operator button
    connect(ui->Button_Neg, SIGNAL(released()), this, SLOT(ChangeSignButtonPressed()));

    // set up equal button
    connect(ui->Button_Equal, SIGNAL(released()), this, SLOT(EqualButtonPressed()));

    // set buttons to their default values
    // disable operand buttons
    ui->Button_Plus->setDisabled(true);
    ui->Button_Min->setDisabled(true);
    ui->Button_Mult->setDisabled(true);
    ui->Button_Div->setDisabled(true);
    ui->Button_Pow->setDisabled(true);
    // enable trig buttons
    ui->Button_Sin->setDisabled(false);
    ui->Button_Cos->setDisabled(false);
    ui->Button_Tan->setDisabled(false);
    ui->Button_Cot->setDisabled(false);
    ui->Button_Log->setDisabled(false);
    ui->Button_NatLog->setDisabled(false);
    ui->Button_Paren_Open->setDisabled(false);
    ui->Button_Bracket_Open->setDisabled(false);
    ui->Button_Paren_Close->setDisabled(true);
    ui->Button_Bracket_Close->setDisabled(true);
    // enable negation button
    ui->Button_Neg->setDisabled(false);
}

Calculator::~Calculator()
{
    delete ui;
}


// method to handle a number button press
void Calculator::NumPressed()
{
    QPushButton *button = (QPushButton *)sender();
    QString buttonValue = button->text();
    QString displayValue = ui->Display->text();

    // if the current display is 0, update to be the new number input
    if(input.size() == 0)
    {
        // set the dispaly to show the newly pressed value
        ui->Display->setText(buttonValue);
        input.push_back(buttonValue);
    }
    else
    {
        // if the current display value is not 0, add the number pressed to the value
        QString newValue = displayValue + buttonValue;
        ui->Display->setText(newValue);

        // check if the most recent input was an operation or a number character (this includes the "." character)
        if(isOperator(input.at(input.size()-1)) == false)
        {
            input.at(input.size()-1).append(buttonValue);
        }
        else
        {
            input.push_back(buttonValue);
        }
    }

    // enable operand buttons
    ui->Button_Plus->setDisabled(false);
    ui->Button_Min->setDisabled(false);
    ui->Button_Mult->setDisabled(false);
    ui->Button_Div->setDisabled(false);
    ui->Button_Pow->setDisabled(false);
    // enable closing brackets/paren
    ui->Button_Bracket_Close->setDisabled(false);
    ui->Button_Paren_Close->setDisabled(false);

    // disable trig functions
    ui->Button_Sin->setDisabled(true);
    ui->Button_Cos->setDisabled(true);
    ui->Button_Tan->setDisabled(true);
    ui->Button_Cot->setDisabled(true);
    ui->Button_Log->setDisabled(true);
    ui->Button_NatLog->setDisabled(true);
    ui->Button_Paren_Open->setDisabled(true);
    ui->Button_Bracket_Open->setDisabled(true);


    // disable negation
    ui->Button_Neg->setDisabled(true);

    // enable the equals button
    ui->Button_Equal->setDisabled(false);
}


// method to handle an operator button press /, *, -, +, ^, sin, cos, tan, cot, log, ln, {, }, (, and )
void Calculator::OperatorButtonPressed()
{
    // store current value in the display
    QString displayValue = ui->Display->text();

    // figure out what button was pushed
    QPushButton *button = (QPushButton *)sender();
    QString buttonValue = button->text();

    // if the current display is 0, update to be the new operator input
    if(input.size() == 0)
    {
        // set the dispaly to show the newly pressed value
        ui->Display->setText(buttonValue);
        input.push_back(buttonValue);
    }
    else
    {
        // if the current display value is not 0, add the operator pressed to the value
        QString newValue = displayValue + " " + buttonValue + " ";
        ui->Display->setText(newValue);
        input.push_back(buttonValue);
    }

    // disable operand buttons
    ui->Button_Plus->setDisabled(true);
    ui->Button_Min->setDisabled(true);
    ui->Button_Mult->setDisabled(true);
    ui->Button_Div->setDisabled(true);
    ui->Button_Pow->setDisabled(true);
    ui->Button_Bracket_Close->setDisabled(true);
    ui->Button_Paren_Close->setDisabled(true);

    // enable trig unless ), ^, or }
    // disable trig functions
    if(buttonValue != ")" && buttonValue != "}" && buttonValue != "^")
    {
        ui->Button_Sin->setDisabled(false);
        ui->Button_Cos->setDisabled(false);
        ui->Button_Tan->setDisabled(false);
        ui->Button_Cot->setDisabled(false);
        ui->Button_Log->setDisabled(false);
        ui->Button_NatLog->setDisabled(false);
        ui->Button_Paren_Open->setDisabled(false);
        ui->Button_Bracket_Open->setDisabled(false);
    }
    // enable operators after closing parenthases/bracket
    if(buttonValue == ")" || buttonValue == "}")
    {
        ui->Button_Plus->setDisabled(false);
        ui->Button_Min->setDisabled(false);
        ui->Button_Mult->setDisabled(false);
        ui->Button_Div->setDisabled(false);
        ui->Button_Pow->setDisabled(false);
        ui->Button_Bracket_Close->setDisabled(false);
        ui->Button_Paren_Close->setDisabled(false);
    }

    // disable the equals button if not evaluatable
    if(buttonValue != ")" && buttonValue != "}")
    {
        ui->Button_Equal->setDisabled(true);
    }
}


// method to handle the press of the equal button
// method will call shunting yard algorithm for current input
void Calculator::EqualButtonPressed()
{
    // double to hold the solution to the math
    double solution = 0.0;

    // get the current display value from the display
    QString displayValue = ui->Display->text();

    // create QString to hold the output value
    QString postFix;

    // check if th einput is greater than 0
    if(input.size() > 0)
    {
        // call the shuntingYard() method
        shuntingYard();
    }

    // check if the output is greater than 0
    if(output.size() > 0)
    {
        // call the evaluation method
        evaluation();
    }

    /*
    for(int i = 0; i < output.size(); i++)
    {
        postFix += output.at(i);
        postFix += " ";
    }
    */

    // check if the calcval is correct, or if need to read from output
    if(output.size() > 0 && output.at(0) == "Invalid Input")
    {
        ui->Display->setText(output.at(0));
    }
    else
    {
        // update the new Display value // for now prints the post fix
        ui->Display->setText(QString::number(calcVal));
    }

    // clear all the data
    output.clear();
    input.clear();
    operators.clear();

    // enable all buttons
    // disable operand buttons
    ui->Button_Plus->setDisabled(true);
    ui->Button_Min->setDisabled(true);
    ui->Button_Mult->setDisabled(true);
    ui->Button_Div->setDisabled(true);
    ui->Button_Pow->setDisabled(true);
    // enable trig buttons
    ui->Button_Sin->setDisabled(false);
    ui->Button_Cos->setDisabled(false);
    ui->Button_Tan->setDisabled(false);
    ui->Button_Cot->setDisabled(false);
    ui->Button_Log->setDisabled(false);
    ui->Button_NatLog->setDisabled(false);
    ui->Button_Paren_Open->setDisabled(false);
    ui->Button_Bracket_Open->setDisabled(false);
    ui->Button_Paren_Close->setDisabled(true);
    ui->Button_Bracket_Close->setDisabled(true);
    // enable negation button
    ui->Button_Neg->setDisabled(false);

}


// method to handle the press of the clear button
void Calculator::ClearButtonPressed()
{
    // reset the calcVal just in case it has been updated
    calcVal = 0.0;

    // clear the input
    input.clear();

    // set the display to show 0.0
    ui->Display->setText(QString::number(calcVal));

    // reset all buttons
    // disable operand buttons
    ui->Button_Plus->setDisabled(true);
    ui->Button_Min->setDisabled(true);
    ui->Button_Mult->setDisabled(true);
    ui->Button_Div->setDisabled(true);
    ui->Button_Pow->setDisabled(true);
    // enable trig buttons
    ui->Button_Sin->setDisabled(false);
    ui->Button_Cos->setDisabled(false);
    ui->Button_Tan->setDisabled(false);
    ui->Button_Cot->setDisabled(false);
    ui->Button_Log->setDisabled(false);
    ui->Button_NatLog->setDisabled(false);
    ui->Button_Paren_Open->setDisabled(false);
    ui->Button_Bracket_Open->setDisabled(false);
    ui->Button_Paren_Close->setDisabled(true);
    ui->Button_Bracket_Close->setDisabled(true);
    // enable negation button
    ui->Button_Neg->setDisabled(false);
    // enable equals button
    ui->Button_Equal->setDisabled(false);
}


// method to handle the unary negation
void Calculator::ChangeSignButtonPressed()
{
    // get the current display value
    // store current value in the display
    QString displayValue = ui->Display->text();

    // unary negation will be represented as "Neg" in the code, but shown as "-" in the window
    // if the current display is 0, update to be the new operator input
    if(input.size() == 0)
    {
        // set the dispaly to show the newly pressed value
        ui->Display->setText("-");
        input.push_back("Neg");
    }
    else
    {
        // if the current display value is not 0, add the operator pressed to the value
        QString newValue = displayValue + " " + "-" + " ";
        ui->Display->setText(newValue);
        input.push_back("Neg");
    }

    // disable operand buttons
    ui->Button_Plus->setDisabled(true);
    ui->Button_Min->setDisabled(true);
    ui->Button_Mult->setDisabled(true);
    ui->Button_Div->setDisabled(true);
    ui->Button_Pow->setDisabled(true);
    ui->Button_Bracket_Close->setDisabled(true);
    ui->Button_Paren_Close->setDisabled(true);
    // disable the equals button
    ui->Button_Equal->setDisabled(true);
}


// method to handle the press of the backspace button
void Calculator::BackButtonPressed()
{
    // temporary string to hold the new value
    QString updatedString;

    // remove the most recent button added
    if (input.size() > 1)
    {
        // remove the last element from the input
        input.pop_back();

        // get the last value to enable proper restting of buttons
        QString lastVal = input.at(input.size() - 1);

        if(isOperator(lastVal) == true)
        {
            // disable operand buttons
            ui->Button_Plus->setDisabled(true);
            ui->Button_Min->setDisabled(true);
            ui->Button_Mult->setDisabled(true);
            ui->Button_Div->setDisabled(true);
            ui->Button_Pow->setDisabled(true);
            ui->Button_Bracket_Close->setDisabled(true);
            ui->Button_Paren_Close->setDisabled(true);

            // enable trig unless ), ^, or }
            // disable trig functions
            if(lastVal != ")" && lastVal != "}" && lastVal != "^")
            {
                ui->Button_Sin->setDisabled(false);
                ui->Button_Cos->setDisabled(false);
                ui->Button_Tan->setDisabled(false);
                ui->Button_Cot->setDisabled(false);
                ui->Button_Log->setDisabled(false);
                ui->Button_NatLog->setDisabled(false);
                ui->Button_Paren_Open->setDisabled(false);
                ui->Button_Bracket_Open->setDisabled(false);
            }
            // enable operators after closing parenthases/bracket
            if(lastVal == ")" || lastVal == "}")
            {
                ui->Button_Plus->setDisabled(false);
                ui->Button_Min->setDisabled(false);
                ui->Button_Mult->setDisabled(false);
                ui->Button_Div->setDisabled(false);
                ui->Button_Pow->setDisabled(false);
            }

            // disable the equals button if not evaluatable
            if(lastVal != ")" && lastVal != "}")
            {
                ui->Button_Equal->setDisabled(true);
            }
        }
        // last val is a number
        else
        {
            // enable operand buttons
            ui->Button_Plus->setDisabled(false);
            ui->Button_Min->setDisabled(false);
            ui->Button_Mult->setDisabled(false);
            ui->Button_Div->setDisabled(false);
            ui->Button_Pow->setDisabled(false);
            // enable closing brackets/paren
            ui->Button_Bracket_Close->setDisabled(false);
            ui->Button_Paren_Close->setDisabled(false);

            // disable trig functions
            ui->Button_Sin->setDisabled(true);
            ui->Button_Cos->setDisabled(true);
            ui->Button_Tan->setDisabled(true);
            ui->Button_Cot->setDisabled(true);
            ui->Button_Log->setDisabled(true);
            ui->Button_NatLog->setDisabled(true);
            ui->Button_Paren_Open->setDisabled(true);
            ui->Button_Bracket_Open->setDisabled(true);


            // disable negation
            ui->Button_Neg->setDisabled(true);

            // enable the equals button
            ui->Button_Equal->setDisabled(false);

        }

        // recreate the string value
        for(int i = 0; i < input.size(); i++)
        {
            if(input.at(i) != "Neg")
            {
                updatedString += input.at(i);
                updatedString += " ";
            }
            else
            {
                updatedString += "-";
            }
        }

        ui->Display->setText(updatedString);
    }
    else if(input.size() == 1)
    {
        // remove the last element from the input
        input.pop_back();

        // set the UI to the default (0)
        ui->Display->setText(QString::number(0.0));

        // reset all buttons to default
        // enable all buttons
        // enable operand buttons
        ui->Button_Plus->setDisabled(false);
        ui->Button_Min->setDisabled(false);
        ui->Button_Mult->setDisabled(false);
        ui->Button_Div->setDisabled(false);
        ui->Button_Pow->setDisabled(false);
        // enable trig buttons
        ui->Button_Sin->setDisabled(false);
        ui->Button_Cos->setDisabled(false);
        ui->Button_Tan->setDisabled(false);
        ui->Button_Cot->setDisabled(false);
        ui->Button_Log->setDisabled(false);
        ui->Button_NatLog->setDisabled(false);
        ui->Button_Paren_Open->setDisabled(false);
        ui->Button_Bracket_Open->setDisabled(false);

        // enable negation button
        ui->Button_Neg->setDisabled(false);
    }

    // build button enable/disable for backspace. Check if the last input is a number or an operand
}


// implement shunting yard algorithm to create postfix expression in reverse polish notation
void Calculator::shuntingYard()
{
    // iterate over input and perform shunting yard algorithm
    for(int i = 0; i < input.size(); i++)
    {
        // create temporary string to hold the current data
        QString tempData = input.at(i);

        // check if the tempData is an operator
        if(isOperator(tempData) == true)
        {
            // check for parenthetical correctness.
            if(tempData == ")" || tempData == "}")
            {
                // flag for complete parentthetical expression
                bool complete = false;

                // iterate over the operator stack (represented as vector) to find the opening of the paren or curly bracket
                while(operators.size() > 0)
                {
                    // get the top of operator stack
                    QString opTop = operators.at(0);

                    // pop the first element
                    operators.erase(operators.begin());

                    // check if the open paren or curly bracket is a trig function
                    if((opTop == "Sin (" && tempData == ")") || (opTop == "Cos (" && tempData == ")") || (opTop == "Tan (" && tempData == ")") || (opTop == "Cot (" && tempData == ")")
                            || (opTop == "ln (" && tempData == ")") || (opTop == "Log (" && tempData == ")"))
                    {
                        // if there is a complete trig/log function, add to the output queue
                        output.push_back(opTop);

                        // set the flag for complete to true
                        complete = true;

                        // exit the loop
                        break;
                    }
                    else if((opTop == "(" && tempData == ")") || (opTop == "{" && tempData == "}"))
                    {
                        // if there is an open parenthasis, set the flag to true
                        complete = true;

                        // exit
                        break;
                    }
                    else
                    {
                        // push the operator to the output queue
                        output.push_back(opTop);
                    }
                }

                // if the complete paren/bracket flag was not set to true, clear the input and tell the user that it is an invalid input
                if(complete == false)
                {
                    // clear the input
                    input.clear();

                    // clear the output
                    output.clear();

                    // clear the operator stack
                    operators.clear();

                    // set the UI to tell invalid input
                    output.push_back("Invalid Input");

                    // break
                    break;
                }
                continue;
            }
            // if any of the open parens or trig/log funcs or negation since they have highest precedence
            else if(tempData == "(" || tempData == "{" || tempData == "Sin (" || tempData == "Cos (" || tempData == "Tan (" || tempData == "Cot (" || tempData == "ln (" || tempData == "Log ("
                    || tempData == "Neg")
            {
                // push the operator into the operator stack
                operators.insert(operators.begin(), 1, tempData);
            }
            // the data is an operator, but not a paren, bracket, trig func, log func, or negation
            else
            {
                // get the precedence of the current element
                int curPrec = precedence(tempData);

                if(operators.size() > 0)
                {
                    while(operators.size() > 0)
                    {
                        // get the top of the operators stack
                        QString opTop = operators.at(0);

                        // pop the top operator
                        operators.erase(operators.begin());

                        // get the precedence of the top
                        int topPrec = precedence(opTop);

                        // compare the precedence of the two operators and react accordingly
                        if(curPrec < topPrec)
                        {
                            // push the top of the operator stack into the output queue
                            output.push_back(opTop);

                            // continue popping
                            for(int i = 0; i < operators.size(); i++)
                            {
                                // get new top
                                QString newTop = operators.at(i);

                                operators.erase(operators.begin() + i);

                                // get the precedence
                                int newTopPrec = precedence(newTop);

                                if(curPrec < newTopPrec)
                                {
                                    output.push_back(newTop);
                                }
                                else
                                {
                                    operators.insert(operators.begin(), 1, tempData);
                                }
                            }

                            // push the current into the operator stack
                            // operators.insert(operators.begin(), 1, tempData);

                            break;
                        }
                        else if(curPrec == topPrec)
                        {
                            // push the top operator into the output queue
                            output.push_back(opTop);

                            // push the current operator into the stack
                            operators.insert(operators.begin(), 1, tempData);
                            break;
                        }
                        // topPrec < curPrec
                        else
                        {
                            // push both elements into the operator stack
                            operators.insert(operators.begin(), 1, opTop);
                            operators.insert(operators.begin(), 1, tempData);
                            break;
                        }
                    }

                    // if we reach the end of the operators stack while iterating, add tempData to the stack
                    if(operators.size() == 0)
                    {
                        // push current operator into the stack
                        operators.insert(operators.begin(), 1, tempData);
                    }
                }
                else
                {
                    // push the current operator into the empty stack
                    operators.insert(operators.begin(), 1, tempData);
                }
            }
        }

        // if the input is not an operator (this means the input is either a number or invalid)
        if(isOperator(tempData) == false)
        {
            // push the number into the output queue
            output.push_back(tempData);
        }

    } // end of for loop iteration over input

    // push the remaining data from the stack and input
    while(operators.size() > 0)
    {
        // push the top of the stack into the output queue
        output.push_back(operators.at(0));

        // pop the top of the stack
        operators.erase(operators.begin());
    }
}


// method to determine if a given input is an operator or not. This is to make comparisons easier.
bool Calculator::isOperator(QString data)
{
    // if statement to check if the input is one of the operators or if it is a number value
    if(data == "+" || data == "-" || data == "*" || data == "/" || data == "^" || data == "Sin (" || data == "Cos (" || data == "Tan (" || data == "Cot (" || data == "ln (" || data == "Log ("
            || data == "(" || data == ")" || data == "{" || data == "}" || data == "Neg")
    {
        return true;
    }
    else
    {
        return false;
    }
}


// method to determine the precidence of a given input. Higher value means higher precidence
int Calculator::precedence(QString data)
{
    // if statements to give the precidence of each operator
    if(data == "+" || data == "-")
    {
        return 2;
    }
    else if(data == "*" || data == "/")
    {
        return 3;
    }
    else if(data == "^" || data == "Neg")
    {
        return 4;
    }
    else if(data == "Sin (" || data == "Cos (" || data == "Tan (" || data == "Cot (" || data == "ln (" || data == "Log ("
            || data == "(" || data == "{" )
    {
        return 1;
    }
    else
    {
        return -1;
    }
}


// method to handle the evaluation of the postfix function output by shuntingYard()
void Calculator::evaluation()
{
    // create eval stack
    vector<QString> evalStack;

    // check if any of the elements contain an open parenthases
    for(int i = 0; i < output.size(); i++)
    {
        if(output.at(i) == "(" || output.at(i) == "{")
        {
            // clear the output
            output.clear();

            // tell the user that this expression is invalid
            output.push_back("Invalid Input");

            break;
        }
    }

    for(int i = 0; i < output.size(); i++)
    {
        if(isOperator(output.at(i)) == true)
        {
            // call operations method (handles binary operators +, -, *, /, ^)
            if(output.at(i) == "+" || output.at(i) == "-" || output.at(i) == "*" || output.at(i) == "/" || output.at(i) == "^")
            {
                // pop the top two elements
                double a = evalStack.at(0).toDouble();
                evalStack.erase(evalStack.begin());
                double b = evalStack.at(0).toDouble();
                evalStack.erase(evalStack.begin());

                // call the operations method
                evalStack.insert(evalStack.begin(), 1, QString::number(binaryOperations(output.at(i), a, b)));
            }
            // call function method (handles sin, cos, cot, tan, log, ln)
            else
            {
                // pop the top element
                double a = evalStack.at(0).toDouble();
                evalStack.erase(evalStack.begin());

                // call the function method
                evalStack.insert(evalStack.begin(), 1, QString::number(funcOperations(output.at(i), a)));
            }

        }
        else
        {
            evalStack.insert(evalStack.begin(), 1, output.at(i));
        }

    }

    // set the top of the stack to the calcval
    calcVal = evalStack.at(0).toDouble();

    // clear the eval stack
    evalStack.clear();

}


// operations method to handle binary operator calculations
double Calculator::binaryOperations(QString op, double a, double b)
{
    if(op == "+")
    {
        // b+a
        return b+a;
    }
    else if(op == "-")
    {
        // b-a
        return b-a;
    }
    else if(op == "*")
    {
        // b*a
        return b*a;
    }
    else if(op == "/")
    {
        // b/a
        return b/a;
    }
    else if(op == "^")
    {
        // b^a
        return qPow(b, a);
    }
    else
    {
        return INT_MIN;
    }
}


// functions method to handle trig and log functions
double Calculator::funcOperations(QString op, double a)
{
    if(op == "Sin (")
    {
        // QtMath sin func
        return qSin(a);
    }
    else if(op == "Cos (")
    {
        // QtMath cos func
        return qCos(a);
    }
    else if(op == "Tan (")
    {
        // QtMath tan func
        return qTan(a);
    }
    else if(op == "Cot (")
    {
        // QtMath cot func/ arctan
        return qAtan(a);
    }
    else if(op == "Log (")
    {
        // QtMath does not contain log base 10 function
        // use general cmath log10() function
        return log10(a);
    }
    else if(op == "ln (")
    {
        // QtMath ln function
        return qLn(a);
    }
    else if(op == "Neg")
    {
        // return a * -1
        return a * -1;
    }
    else
    {
        return INT_MIN;
    }
}
















